{"version":3,"sources":["..\\..\\..\\..\\UserInterface.fs"],"names":[],"mappings":"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","file":"UserInterface.js","sourcesContent":["ï»¿namespace AcademicMarkdown\r\nopen System\r\nopen Identifiers\r\nopen Types\r\nopen States\r\nopen Compiler\r\nopen Utility\r\nopen System.Text\r\nopen Fable.Core\r\nopen Fable.Import\r\nopen Fable.Import.Browser\r\nopen Fable.Core.JsInterop\r\n\r\nmodule UserInterface = \r\n\r\n    \r\n//    let str = \"   ##123###fff\\n[1234]:http://123412341234\\n13513515\\n[someurl][1234]\\n```\\n1234\\nnewline\\njava\\n```\"\r\n\r\n    // get the references\r\n    \r\n    // let mutable links: Map<string,string> = Map [];\r\n\r\n\r\n    let compileAMD inputString = \r\n        let inputLines = inputString |> splitByLine |> preProcess\r\n\r\n        let mutable outputLines: string list = [];\r\n\r\n        initState()\r\n        let maxLineIndex = inputLines.Length - 1\r\n        let mutable lineIndex = 0\r\n\r\n        //pre-process (all references)\r\n        lineIndex <- 0\r\n        while (lineIndex <= maxLineIndex) do\r\n            let eachLine = inputLines.[lineIndex]\r\n            match eachLine with\r\n            | IsLinkRef link -> \r\n                match link with\r\n                | Link (id,url,title) -> \r\n                    setLinks (Map.add id url links)\r\n                | _ -> ()\r\n            | IsFootnote footnote ->\r\n                match footnote with\r\n                | Footnote (id, text) ->\r\n                    setFootnotes (Map.add id (uuid() ,text) footnotes)\r\n                | _ -> ()\r\n            | _ -> ()\r\n            lineIndex <- lineIndex + 1\r\n\r\n        //blockLevel\r\n        lineIndex <- 0\r\n        while (lineIndex <= maxLineIndex) do\r\n            let eachLine = inputLines.[lineIndex]\r\n            let output line = \r\n                outputLines <- line :: outputLines \r\n            match eachLine with\r\n            | IsLinkRef link -> ()\r\n            | IsFootnote footnote -> ()\r\n            | IsHorizontalRuleLine -> output \"<hr>\"\r\n            | IsHeading heading -> \r\n                heading |> makeHeading |> makeEmphasis |> output\r\n                addHeading heading\r\n            | IsAltHeading heading -> \r\n                heading |> makeHeading |> makeEmphasis |> output\r\n            | IsLazyQuote quote ->\r\n                quote |> makeBlockQuote |> makeEmphasis |> output\r\n            | IsCodeBlockStart language ->\r\n                if language = \"\" then\r\n                    output (\"<pre><code>\")\r\n                else\r\n                    output (\"<pre><code class='\" + language + \"'> \")\r\n                let mutable codeLineIndex = lineIndex + 1\r\n                let mutable foundCodeBlockEnd = false\r\n                while (codeLineIndex <= maxLineIndex && foundCodeBlockEnd = false) do\r\n                    let inputLine = inputLines.[codeLineIndex]\r\n                    match inputLine with\r\n                    | IsCodeBlockEnd ->\r\n                        output \"</code></pre>\"\r\n                        lineIndex <- codeLineIndex\r\n                        foundCodeBlockEnd <- true\r\n                    | _ -> \r\n                        output (htmlEncode inputLine + \"\\n\")\r\n                        codeLineIndex <- codeLineIndex + 1\r\n                        lineIndex <- codeLineIndex\r\n            | IsFlowChartStart ->\r\n                let flowChartId = uuid()\r\n                let mutable flowChartCode = \"\"\r\n                let mutable codeLineIndex = lineIndex + 1\r\n                let mutable foundCodeBlockEnd = false\r\n                while (codeLineIndex <= maxLineIndex && foundCodeBlockEnd = false) do\r\n                    let inputLine = inputLines.[codeLineIndex]\r\n                    match inputLine with\r\n                    | IsCodeBlockEnd ->\r\n                        lineIndex <- codeLineIndex\r\n                        foundCodeBlockEnd <- true\r\n                    | _ -> \r\n                        flowChartCode <- flowChartCode + inputLine + \"\\n\"\r\n                        codeLineIndex <- codeLineIndex + 1\r\n                        lineIndex <- codeLineIndex\r\n                setFlowCharts (Map.add flowChartId flowChartCode flowcharts)\r\n                output (\"<div id='\" + flowChartId + \"'>\" + flowChartCode + \"</div>\")\r\n            | IsCollapesStart (text:string)->\r\n                let id = uuid()\r\n                let button = if text.Length > 0 then text else \"Reveal\"\r\n                output (\"<button data-toggle='collapse' data-target='#\" + id + \"' class='btn btn-primary btn-xs'>\" + button + \"</button><br><div id='\" + id + \"' class='collapse'>\")\r\n            | IsCollapesEnd ->\r\n                output \"</div>\"\r\n            | IsExcelTableRow row ->\r\n                let mutable table = [row]\r\n                let mutable tableLineIndex = lineIndex + 1\r\n                let mutable foundTableEnd = false\r\n                while (tableLineIndex <= maxLineIndex && foundTableEnd = false) do\r\n                    let inputLine = inputLines.[tableLineIndex]\r\n                    match inputLine with\r\n                    | IsExcelTableRow cells ->\r\n                        table <- (cells :: table)\r\n                        tableLineIndex <- tableLineIndex + 1\r\n                        lineIndex <- tableLineIndex\r\n                    | _ -> \r\n                        foundTableEnd <- true\r\n                        lineIndex <- tableLineIndex\r\n                table <- table |> List.rev\r\n                output (makeTable table)\r\n             | IsPipeTableRow row ->\r\n                let mutable table = [row]\r\n                let mutable tableLineIndex = lineIndex + 2\r\n                let mutable foundTableEnd = false\r\n                while (tableLineIndex <= maxLineIndex && foundTableEnd = false) do\r\n                    let inputLine = inputLines.[tableLineIndex]\r\n                    match inputLine with\r\n                    | IsPipeTableRow cells ->\r\n                        table <- (cells :: table)\r\n                        tableLineIndex <- tableLineIndex + 1\r\n                        lineIndex <- tableLineIndex\r\n                    | _ -> \r\n                        foundTableEnd <- true\r\n                        lineIndex <- tableLineIndex\r\n                table <- table |> List.rev\r\n                output (makeTable table)\r\n            | IsBlankLine _ ->\r\n                output \"<br>\"\r\n            | _ -> \r\n                eachLine + \"<br>\" |> makeEmphasis |> output\r\n            lineIndex <- lineIndex + 1\r\n        \r\n\r\n        //post-process \r\n        //table of contents\r\n        lineIndex <- 0\r\n        let outputLinesArray = outputLines |> List.toArray\r\n        while (lineIndex <= maxLineIndex) do\r\n            let eachLine = outputLinesArray.[lineIndex]\r\n            match eachLine with\r\n            | IsTableOfContent -> \r\n                outputLinesArray.[lineIndex] <- makeEmphasis (makeTableOfContent()  + \"<br>\")\r\n            | _ -> ()\r\n            lineIndex <- lineIndex + 1\r\n        outputLines <- outputLinesArray |> Array.toList         \r\n\r\n//        for eachLine in outputLines|> List.rev do \r\n//            printfn \"%A\" eachLine\r\n        outputLines <- makeFootnote() :: outputLines\r\n        outputLines|> List.rev |> String.concat \"\"\r\n        \r\n        \r\n//    compileAMD str\r\n    window?compileAMD <- compileAMD\r\n"]}